<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>íŠ¹ìˆ˜ë¬¸ì ê²€ì‚¬ê¸°</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --bg: #f5f7fa;
        --card-bg: #fff;
        --text: #333;
        --accent: #2c3e50;
      }
      body.dark {
        --bg: #1e1e1e;
        --card-bg: #2a2a2a;
        --text: #eee;
        --accent: #79b8ff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        background: var(--bg);
        color: var(--text);
        font-family: "Segoe UI", sans-serif;
        padding: 2rem;
        transition: all 0.3s ease;
      }
      h2 {
        text-align: center;
        color: var(--accent);
      }
      .wrapper {
        display: flex;
        flex-direction: column;
      }
      textarea {
        height: 300px;
        padding: 1rem;
        font-size: 1rem;
        border-radius: 8px;
        background: var(--card-bg);
        color: var(--text);
        border: 1px solid #ccc;
        white-space: pre;
        font-family: monospace;
        resize: vertical;
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 1rem;
      }
      button {
        padding: 0.5rem 1rem;
        border-radius: 6px;
        border: none;
        background: var(--accent);
        color: white;
        font-weight: bold;
        cursor: pointer;
      }
      .results {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center;
        margin-top: 1rem;
      }
      .card {
        background: var(--card-bg);
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        text-align: center;
        min-width: 100px;
        border: 2px solid transparent;
      }
      .even {
        border-color: #4caf50;
      }
      .odd {
        border-color: #e74c3c;
      }
      .symbol {
        font-size: 1.5rem;
        font-weight: bold;
      }
      canvas {
        max-width: 100%;
        margin-top: 2rem;
      }
      .mismatch-box {
        width: 100%;
        background: #ffe4e1;
        color: #c0392b;
        padding: 1rem;
        border-radius: 8px;
        font-size: 0.95rem;
        white-space: pre-wrap;
        margin-bottom: 1rem;
      }
      #manualModal {
        display: none;
        position: fixed;
        top: 10%;
        left: 10%;
        width: 80%;
        height: 80%;
        background: var(--card-bg);
        color: var(--text);
        border: 2px solid var(--accent);
        border-radius: 10px;
        overflow: auto;
        padding: 2rem;
        z-index: 9999;
      }
    </style>
  </head>
  <body>
    <h2>íŠ¹ìˆ˜ë¬¸ì ê²€ì‚¬ê¸°</h2>

    <div class="controls">
      <button onclick="showManual()">ğŸ“˜ ì‚¬ìš©ì„¤ëª…ì„œ</button>
      <button onclick="resetText()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
      <button onclick="pasteFromClipboard()">ğŸ“¥ ë¶™ì—¬ë„£ê¸°</button>
      <button onclick="autoCorrect()">ğŸ› ï¸ ì˜¤ë¥˜ ë¶€ë¶„ í‘œì‹œ</button>
      <button onclick="copyToClipboard()">ğŸ“‹ ë³µì‚¬</button>
      <button onclick="downloadResult()">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</button>
      <button onclick="toggleTheme()">â˜€ï¸/ğŸŒ™ í…Œë§ˆ ì „í™˜</button>
    </div>
    <!-- ë§ì¶¤ë²• ê²€ì‚¬ê¸° ì„ íƒ ë¼ë””ì˜¤ ë²„íŠ¼: ì…ë ¥ì°½ ìœ„ë¡œ ì´ë™ -->
    <div
      style="
        display: flex;
        justify-content: center;
        gap: 2em;
        margin: 1.5em 0 0.5em 0;
        align-items: center;
      "
    >
      <label style="margin-right: 0.7em; cursor: pointer; font-size: 1.05em">
        <input
          type="radio"
          name="spellchecker"
          value="naver"
          onclick="openSpellChecker('naver')"
        />
        ë„¤ì´ë²„ ë§ì¶¤ë²• ê²€ì‚¬ê¸°
      </label>
      <label style="cursor: pointer; font-size: 1.05em">
        <input
          type="radio"
          name="spellchecker"
          value="barun"
          onclick="openSpellChecker('barun')"
        />
        ë°”ë¥¸í•œê¸€ ë§ì¶¤ë²• ê²€ì‚¬ê¸°
      </label>
    </div>
    <div class="wrapper">
      <textarea
        id="inputText"
        placeholder="ì—¬ê¸°ì— í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
      ></textarea>
      <div class="mismatch" id="mismatchBox"></div>
    </div>

    <div class="results" id="output"></div>
    <canvas id="chart" height="100"></canvas>

    <!-- ì‚¬ìš©ì„¤ëª…ì„œ ëª¨ë‹¬ -->
    <div id="manualModal">
      <h3>ğŸ“˜ íŠ¹ìˆ˜ë¬¸ì ê²€ì‚¬ê¸° ì‚¬ìš© ì„¤ëª…ì„œ</h3>
      <p>
        <strong>1. í…ìŠ¤íŠ¸ ì…ë ¥</strong><br />
        ê²€ì‚¬í•˜ê³  ì‹¶ì€ ë¬¸ì¥ì„ ìœ„ í…ìŠ¤íŠ¸ ìƒìì— ë¶™ì—¬ë„£ê±°ë‚˜ ì§ì ‘ ì…ë ¥í•˜ì„¸ìš”.
      </p>
      <div
        style="
          background: #f1f8ff;
          border-radius: 8px;
          padding: 1em;
          margin: 1em 0;
          letter-spacing: 0.02em;
          line-height: 1.8;
        "
      >
        <b>ë²„íŠ¼ë³„ ì‚¬ìš©ë²• ì•ˆë‚´</b><br />
        <ul style="margin: 0 0 0 1em; padding: 0; list-style-type: none">
          <li style="margin-bottom: 1.1em">
            <b>ğŸ“˜ ì‚¬ìš©ì„¤ëª…ì„œ</b>:<br />
            ì´ ì„¤ëª…ì„œ(ë„ì›€ë§) ì°½ì„ ì—½ë‹ˆë‹¤.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸ—‘ï¸ ì´ˆê¸°í™”</b>:<br />
            í…ìŠ¤íŠ¸ ìƒìì˜ ëª¨ë“  ë‚´ìš©ì„ ì§€ì›ë‹ˆë‹¤.<br />
            ìƒˆë¡œ ì…ë ¥í•˜ê±°ë‚˜, ê¸°ì¡´ ë‚´ìš©ì„ ëª¨ë‘ ì‚­ì œí•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸ“¥ ë¶™ì—¬ë„£ê¸°</b>:<br />
            í´ë¦½ë³´ë“œì— ë³µì‚¬ëœ ë‚´ìš©ì„ í…ìŠ¤íŠ¸ ìƒìì— ë¶™ì—¬ë„£ìŠµë‹ˆë‹¤.<br />
            ë‹¤ë¥¸ ê³³ì—ì„œ ë³µì‚¬í•œ ê¸€ì„ ë°”ë¡œ ì…ë ¥í•  ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸ› ï¸ ì˜¤ë¥˜ ë¶€ë¶„ í‘œì‹œ</b>:<br />
            ìŒì´ ë§ì§€ ì•ŠëŠ” íŠ¹ìˆ˜ë¬¸ìì— <code>ğŸ”º</code> í‘œì‹œê°€ ì¶”ê°€ë©ë‹ˆë‹¤.<br />
            ì˜¤ë¥˜ ìœ„ì¹˜ë¥¼ í•œëˆˆì— í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸ“‹ ë³µì‚¬</b>:<br />
            ì…ë ¥í•œ í…ìŠ¤íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í•©ë‹ˆë‹¤.<br />
            ë‹¤ë¥¸ ê³³ì— ë¶™ì—¬ë„£ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸ“¥ ë‹¤ìš´ë¡œë“œ</b>:<br />
            ì…ë ¥í•œ í…ìŠ¤íŠ¸ë¥¼ íŒŒì¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.<br />
            ê²°ê³¼ë¥¼ ë³´ê´€í•˜ê±°ë‚˜, ë‹¤ë¥¸ ê³³ì— ì œì¶œí•  ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ğŸŒ™/â˜€ï¸ í…Œë§ˆ ì „í™˜</b>:<br />
            ë°ì€ í…Œë§ˆì™€ ì–´ë‘ìš´ í…Œë§ˆë¥¼ ì „í™˜í•©ë‹ˆë‹¤.<br />
            ëˆˆì˜ í”¼ë¡œë„ë¥¼ ì¤„ì´ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ì„¸ìš”.
          </li>
          <li style="margin-bottom: 1.1em">
            <b>ë§ì¶¤ë²• ê²€ì‚¬</b>:<br />
            <b>ë„¤ì´ë²„</b> ë˜ëŠ” <b>ë°”ë¥¸í•œê¸€(ë¶€ì‚°ëŒ€)</b> ë§ì¶¤ë²• ê²€ì‚¬ê¸° ë¼ë””ì˜¤
            ë²„íŠ¼ì„ í´ë¦­í•˜ë©´, ì…ë ¥í•œ í…ìŠ¤íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ê³  í•´ë‹¹ ê²€ì‚¬ê¸°
            í˜ì´ì§€ê°€ ìƒˆ ì°½ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤.<br />
            <b
              >ë¼ë””ì˜¤ ë²„íŠ¼ í´ë¦­ í›„ ìƒˆ ì°½ì—ì„œ Ctrl+V(ë˜ëŠ” ë§ˆìš°ìŠ¤ ìš°í´ë¦­ â†’
              ë¶™ì—¬ë„£ê¸°)</b
            >ë¡œ ì…ë ¥ì°½ì— ë¶™ì—¬ë„£ì€ ë’¤, 'ê²€ì‚¬í•˜ê¸°' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.<br />
            <span style="color: #888"
              >â€» ìë™ ì…ë ¥ì€ ë¶ˆê°€í•˜ë¯€ë¡œ ë°˜ë“œì‹œ ì§ì ‘ ë¶™ì—¬ë„£ê¸° í•´ì£¼ì„¸ìš”.</span
            >
          </li>
        </ul>
      </div>
      <br /><button onclick="hideManual()">ë‹«ê¸°</button>
    </div>

    <script>
      // í˜ì´ì§€ ì‹œì‘ ì‹œ ë¸Œë¼ìš°ì € ìºì‹œ(localStorage, sessionStorage, cookie)ë¥¼ ìµœëŒ€í•œ ì‚­ì œ
      window.onload = function () {
        // localStorageì™€ sessionStorage ë¹„ìš°ê¸°
        try {
          localStorage.clear();
          sessionStorage.clear();
        } catch (e) {}
        // ì¿ í‚¤ ì‚­ì œ (í˜„ì¬ ë„ë©”ì¸, ê²½ë¡œ í•œì •)
        document.cookie.split(";").forEach(function (c) {
          try {
            document.cookie = c
              .replace(/^ +/, "")
              .replace(
                /=.*/,
                "=;expires=" + new Date(0).toUTCString() + ";path=/"
              );
          } catch (e) {}
        });
      };

      const textarea = document.getElementById("inputText");
      const output = document.getElementById("output");
      const mismatchBox = document.getElementById("mismatchBox");
      const ctx = document.getElementById("chart").getContext("2d");
      const body = document.body;

      const symbolPairs = {
        "â€œ": "â€",
        "â€˜": "â€™",
        "(": ")",
        "<": ">",
        "ã€ˆ": "ã€‰",
        "ã€Š": "ã€‹",
        "ã€": "ã€",
        "[": "]",
        "ã€Œ": "ã€",
        '"': '"',
        "'": "'",
      };

      const symbols = [
        "â€œ",
        "â€",
        "â€˜",
        "â€™",
        "(",
        ")",
        "<",
        ">",
        "ã€ˆ",
        "ã€‰",
        "ã€Š",
        "ã€‹",
        "ã€",
        "ã€",
        "[",
        "]",
        "ã€Œ",
        "ã€",
        '"',
        "'",
        "*",
        ",",
        "~",
        "-",
        ":",
        ";",
        "!",
        "?",
        ".",
        "â€¦",
        "Â·",
        "â€¢",
        "_",
      ];

      let chart;

      function countDoubleSpaces(text) {
        const matches = text.match(/  /g);
        return matches ? matches.length : 0;
      }

      function updateCounts() {
        const text = textarea.value;
        const counts = symbols.map((s) => {
          const count = (
            text.match(
              new RegExp(s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g")
            ) || []
          ).length;
          return { symbol: s, count };
        });

        const doubleSpaceCount = countDoubleSpaces(text);
        const mismatches = checkBalancedPairs(text);
        const unbalancedSet = new Set(mismatches.map((m) => m.char));

        output.innerHTML =
          counts
            .filter(({ symbol, count }) => count > 0)
            .map(({ symbol, count }) => {
              const isPairCheck =
                symbol in symbolPairs ||
                Object.values(symbolPairs).includes(symbol);
              const isBalanced = !isPairCheck || !unbalancedSet.has(symbol);
              const icon = isBalanced ? "âœ…" : "âš ï¸";
              const cardClass = isBalanced ? "even" : "odd";

              return `<div class="card ${cardClass}">
              <div class="symbol">${symbol}</div>
              <div>${count}ê°œ ${icon}</div>
            </div>`;
            })
            .join("") +
          `<div class="card even">
     <div class="symbol">VV</div>
     <div>${doubleSpaceCount}ê°œ</div>
   </div>`;

        if (mismatches.length) {
          mismatchBox.innerHTML = `<div class="mismatch-box">${mismatches
            .map(
              (m, idx) =>
                `<span class="mismatch-msg" data-index="${m.index}" style="cursor:pointer; text-decoration:underline;">â— ${m.type} â†’ ${m.line}í–‰ ${m.column}ë²ˆì§¸ ê¸€ì '${m.char}'</span>`
            )
            .join("<br>")}</div>`;
        } else {
          mismatchBox.innerHTML = "";
        }

        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: [...counts.map((c) => c.symbol), "VV"],
            datasets: [
              {
                label: "ë¬¸ì ê°œìˆ˜",
                data: [...counts.map((c) => c.count), doubleSpaceCount],
                backgroundColor: "#3498db",
              },
            ],
          },
          options: {
            responsive: true,
            plugins: { legend: { display: false } },
          },
        });
      }

      function checkBalancedPairs(text) {
        const openSet = Object.keys(symbolPairs);
        const closeSet = Object.values(symbolPairs);
        const stack = [];
        const mismatches = [];
        const lines = text.split("\n");
        let globalIndex = 0;

        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          for (let i = 0; i < line.length; i++) {
            const char = line[i];

            if (char === '"' || char === "'") {
              const last = stack[stack.length - 1];
              if (last && last.char === char) {
                stack.pop();
              } else {
                stack.push({
                  char,
                  index: globalIndex + i,
                  line: lineNum + 1,
                  column: i + 1,
                });
              }
            } else if (openSet.includes(char)) {
              stack.push({
                char,
                index: globalIndex + i,
                line: lineNum + 1,
                column: i + 1,
              });
            } else if (closeSet.includes(char)) {
              const last = stack[stack.length - 1];
              if (last && symbolPairs[last.char] === char) {
                stack.pop();
              } else {
                mismatches.push({
                  type: "ë‹«í˜ë§Œ ìˆìŒ",
                  char,
                  index: globalIndex + i,
                  line: lineNum + 1,
                  column: i + 1,
                });
              }
            }
          }
          globalIndex += line.length + 1;
        }

        stack.forEach((item) => {
          mismatches.push({
            type: "ì—´ë¦¼ë§Œ ìˆìŒ",
            char: item.char,
            index: item.index,
            line: item.line,
            column: item.column,
          });
        });

        return mismatches;
      }

      function autoCorrect() {
        textarea.value = textarea.value.replace(/ğŸ”º/g, "");
        const text = textarea.value;
        const mismatches = checkBalancedPairs(text);

        if (mismatches.length === 0) {
          updateCounts();
          alert("âœ¨ ëª¨ë“  ìŒì´ ì˜¬ë°”ë¥´ê²Œ ë§ì¶°ì ¸ ìˆìŠµë‹ˆë‹¤!");
          return;
        }

        let newText = text.split("");
        mismatches.forEach((item) => {
          newText[item.index] = "ğŸ”º" + newText[item.index];
        });
        textarea.value = newText.join("");
        updateCounts();

        navigator.clipboard
          .writeText(textarea.value)
          .then(() => alert("ğŸ”§ ì˜¤ë¥˜ ìœ„ì¹˜ì— ğŸ”º í‘œì‹œí•˜ê³  ë³µì‚¬ ì™„ë£Œ!"))
          .catch(() => alert("âŒ ë³µì‚¬ ì‹¤íŒ¨!"));
      }

      function resetText() {
        textarea.value = "";
        updateCounts();
      }

      function pasteFromClipboard() {
        navigator.clipboard
          .readText()
          .then((text) => {
            textarea.value = text;
            updateCounts();
          })
          .catch(() => alert("âŒ ë¶™ì—¬ë„£ê¸° ì‹¤íŒ¨!"));
      }

      function copyToClipboard() {
        navigator.clipboard
          .writeText(textarea.value)
          .then(() => alert("ğŸ“‹ ë³µì‚¬ ì™„ë£Œ!"))
          .catch(() => alert("âŒ ë³µì‚¬ ì‹¤íŒ¨!"));
      }

      function downloadResult() {
        const blob = new Blob([textarea.value], { type: "text/plain" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "ë¬¸ì¥ê²°ê³¼.txt";
        link.click();
      }

      function toggleTheme() {
        body.classList.toggle("dark");
      }

      function showManual() {
        document.getElementById("manualModal").style.display = "block";
      }

      function hideManual() {
        document.getElementById("manualModal").style.display = "none";
      }

      function openSpellChecker(type) {
        const text = textarea.value;
        if (!text.trim()) {
          alert("ê²€ì‚¬í•  ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.");
          document
            .querySelectorAll("input[name=spellchecker]")
            .forEach((r) => (r.checked = false));
          return;
        }
        let url = "";
        if (type === "barun") {
          url = "https://nara-speller.co.kr/speller";
        } else if (type === "naver") {
          url =
            "https://search.naver.com/search.naver?where=nexearch&sm=top_sug.pre&fbm=0&acr=1&acq=%ED%95%9C%EA%B5%AD%EC%96%B4+%EB%A7%9E%EC%B6%A4%EB%B2%95&qdt=0&ie=utf8&query=%ED%95%9C%EA%B5%AD%EC%96%B4+%EB%A7%9E%EC%B6%A4%EB%B2%95+%EA%B2%80%EC%82%AC%EA%B8%B0";
        } else {
          alert("ë§ì¶¤ë²• ê²€ì‚¬ê¸°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
          return;
        }
        navigator.clipboard
          .writeText(text)
          .then(() => {
            alert(
              "í…ìŠ¤íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆ ì°½ì—ì„œ Ctrl+Vë¡œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”."
            );
            window.open(url, "_blank");
            document
              .querySelectorAll("input[name=spellchecker]")
              .forEach((r) => (r.checked = false));
          })
          .catch(() => {
            alert("í´ë¦½ë³´ë“œ ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ ì£¼ì„¸ìš”.");
            document
              .querySelectorAll("input[name=spellchecker]")
              .forEach((r) => (r.checked = false));
          });
      }

      // mismatchBox ë‚´ ì˜¤ë¥˜ ë©”ì‹œì§€ í´ë¦­ ì‹œ textarea í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™ ë° í•˜ì´ë¼ì´íŠ¸
      mismatchBox.addEventListener("click", function (e) {
        if (e.target.classList.contains("mismatch-msg")) {
          const idx = Number(e.target.getAttribute("data-index"));
          textarea.focus();
          textarea.setSelectionRange(idx, idx + 1);
          // ìŠ¤í¬ë¡¤ ë³´ì •
          const lines = textarea.value.substr(0, idx).split("\n").length;
          textarea.scrollTop = (lines - 1) * 20;
        }
      });

      textarea.addEventListener("input", updateCounts);
      updateCounts();
    </script>
  </body>
</html>
